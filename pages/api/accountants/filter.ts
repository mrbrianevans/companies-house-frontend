import type { NextApiRequest, NextApiResponse } from "next";
import { getDatabasePool } from "../../../helpers/connectToDatabase";
import { IFilter, IStringFilter } from "../../../types/IFilters";

// /api/accountants/filter
export default async (req: NextApiRequest, res: NextApiResponse) => {
  let { body: filters }: { body: IFilter[] } = req;
  // if(typeof filters === 'string') filters = JSON.parse(filters)
  console.log("REQUEST FILTERS: ", filters);
  const queries: string[] = [],
    values: any[] = [];
  for (const filter of filters) {
    //todo: each type of filter has a function that returns a sql query
    if (filter.type === "string") {
      const { query, value } = filterBySoftware(filter);
      queries.push(query); //todo: need to update the $1 references for the number of values
      values.push(value); //todo: I don't think the concat method actually works
    }
  }
  //todo: combine all the sql queries generated by each filter into one massive sql query
  if (queries.length) {
    const pool = await getDatabasePool();
    const { rows: matches } = await pool.query(queries[0], values[0]);
    res.status(200).json(matches);
  } else res.json(queries);
}

const filterBySoftware: (
  filter: IStringFilter
) => { query: string; value: any[] } = (filter) => {
  console.log(filter.category, "is filter category");
  if (filter.category !== "production software")
    throw new Error("Wrong category function used");
  // this is matching accounts who either do or who don't use the specified software
  const sqlGetPractices = `
      SELECT DISTINCT value FROM accounts WHERE label='Name of entity accountants' AND company_number
      IN (
          SELECT DISTINCT company_number FROM accounts 
          WHERE label='Name of production software' AND value=$1 LIMIT 1000
      ) LIMIT 10;
  `.replace("IN", filter.exclude ? " NOT IN " : "IN");
  console.log(
    "Querying:",
    sqlGetPractices.replace("$1", "'" + filter.values[0].toString() + "'")
  );
  return { query: sqlGetPractices, value: [filter.values[0].toString()] };
}
