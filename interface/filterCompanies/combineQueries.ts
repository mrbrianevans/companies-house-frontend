import { IFilter } from '../../types/IFilters'
import { getCompanyFilterList } from './listOfFilters'
import { prettyPrintSqlQuery } from '../../helpers/prettyPrintSqlQuery'
import { IMinorQuery } from '../../types/IQueries'

export const combineQueries: (filters: IFilter[], limit?: number) => IMinorQuery = (filters, limit) => {
  const filterMap = getCompanyFilterList()
  const queries: string[] = [],
    values: any[] = []
  let valueCounter = 1
  for (const filter of filters) {
    //each type of filter has a function that returns a sql query
    const { query, value } = filterMap.get(filter.category).filter(filter)
    // updates the $1 references for the number of values
    queries.push(
      query.replace(/\?/gm, () => {
        return '$' + valueCounter++
      })
    )
    values.push(value)
  }
  //combines all the sql queries generated by each filter into one massive sql query
  //todo - if the filter is excluded, it should use EXCEPT rather than INTERSECT
  let bigQuery =
    'WITH matches AS (' +
    (queries.length ? queries.join(' INTERSECT ') : 'SELECT * FROM sic LIMIT 0') +
    ')' +
    `
          SELECT DISTINCT ON (c.number, c.name) c.name   as name,
                                                c.number as company_number,
                                                c.category,
                                                c.date   as date_of_creation
          FROM (matches a
                   JOIN companies c ON c.number = a.company_number
                   JOIN detailed_postcodes p ON c.postcode = p.postcode)
        ${limit ? 'LIMIT ' + limit : ''}
      `
  let bigValue = values.flat()
  // const prettyPrintQuery = prettyPrintSqlQuery(bigQuery, bigValue)
  // console.log('in the combine queries file', prettyPrintQuery)
  return { query: bigQuery, value: bigValue }
}
